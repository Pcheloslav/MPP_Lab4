using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;
using System.Data.Common;
using System.Reflection.Metadata.Ecma335;
using System;

namespace TestsLibrary
{
    public class TestsGenerator
    {
        public static TargetFile[] Generate(SourceFile sourceFile, string outputPath)
        {
            CompilationUnitSyntax root = CSharpSyntaxTree.ParseText(sourceFile.Content).GetCompilationUnitRoot();

            // Generate usings
            var sourceNamespaces = root.DescendantNodes().OfType<NamespaceDeclarationSyntax>();
            var sourceUsings = root.DescendantNodes().OfType<UsingDirectiveSyntax>();
            var usings = new SyntaxList<UsingDirectiveSyntax>(sourceUsings)
                .Add(UsingDirective(ParseName("System.Collections.Generic")))
                .Add(UsingDirective(ParseName("NUnit.Framework")))
                .AddRange(
                    sourceNamespaces
                        .Select(ns => GetFullNamespaceName(ns))
                        .Where(nsName => !string.IsNullOrEmpty(nsName))
                        .Select(nsName => UsingDirective(IdentifierName(nsName)))
                );

            // Generate test classes for public classes
            var classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>()
                .Where(@class => @class.Modifiers.Any(SyntaxKind.PublicKeyword));
            var testFiles = classes.Select(@class => {
                var testNsString = GetFullNamespaceName(@class) + ".Tests";
                if (testNsString.StartsWith("."))
                {
                    testNsString = testNsString.Remove(0, 1);
                }

                var testNs = NamespaceDeclaration(IdentifierName(testNsString));
                var testClass = GenerateTestClass(@class);

                var compilationUnit = CompilationUnit()
                    .WithUsings(usings)
                    .AddMembers(testNs.AddMembers(testClass));

                return new TargetFile(
                    sourceFile.Path,
                    outputPath + "/" + testClass.Identifier.Text + ".cs",
                    compilationUnit.NormalizeWhitespace().ToFullString());
            }).ToArray();
            return testFiles;
        }

        private static ClassDeclarationSyntax GenerateTestClass(ClassDeclarationSyntax @class)
        {
            var testFixtureAttribute = SingletonList(AttributeList(
                SingletonSeparatedList(Attribute(IdentifierName("TestFixture")))));

            var testMethods = GenerateTestMethods(@class);

            var testClass = ClassDeclaration(@class.Identifier.Text + "Tests")
                .WithAttributeLists(testFixtureAttribute)
                .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                .AddMembers(testMethods);

            return testClass;
        }

        private static MemberDeclarationSyntax[] GenerateTestMethods(ClassDeclarationSyntax @class)
        {
            // Test attribute
            var testAttribute = SingletonList(AttributeList(
                SingletonSeparatedList(Attribute(IdentifierName("Test")))));

            // Void return type
            var returnType = PredefinedType(Token(SyntaxKind.VoidKeyword));

            // Body with an assertion
            var body = Block(
                ExpressionStatement(
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression, IdentifierName("Assert"), IdentifierName("Fail")
                        )
                    ).WithArgumentList(
                        ArgumentList(
                            SingletonSeparatedList(
                                Argument(
                                    LiteralExpression(
                                        SyntaxKind.StringLiteralExpression, Literal("autogenerated")
                                    )
                                )
                            )
                        )
                    )
                )
            );

            var result = new List<MemberDeclarationSyntax>();
            var methods = @class.DescendantNodes().OfType<MethodDeclarationSyntax>()
                .Where(method => method.Modifiers.Any(SyntaxKind.PublicKeyword))
                .OrderBy(method => method.Identifier.Text).ToList();

            var methodIndex = -1;
            for (int i = 0; i < methods.Count; i++)
            {
                var methodName = GetTestMethodName(methods, i, ref methodIndex);
                result.Add(
                    MethodDeclaration(returnType, methodName)
                        .WithAttributeLists(testAttribute)
                        .WithModifiers(methods[i].Modifiers)
                        .WithBody(body)
                );
            }

            return result.ToArray();
        }

        private static bool IsSameNameAsNextMethod(List<MethodDeclarationSyntax> methods, int i)
        {
            return (i < methods.Count - 1) &&
                (methods[i].Identifier.Text == methods[i + 1].Identifier.Text);
        }

        private static bool IsSameNameAsPrevMethof(List<MethodDeclarationSyntax> methods, int i)
        {
            return (i > 0) &&
                (methods[i].Identifier.Text == methods[i - 1].Identifier.Text);
        }

        private static string GetTestMethodName(List<MethodDeclarationSyntax> methods, int i, ref int methodIndex)
        {
            if (IsSameNameAsNextMethod(methods, i))
            {
                methodIndex = methodIndex < 0 ? 1 : methodIndex + 1;
            }
            else if (IsSameNameAsPrevMethof(methods, i))
            {
                methodIndex++;
            }
            else
            {
                methodIndex = -1;
            }

            return methods[i].Identifier.Text +
                (methodIndex < 0 ? "" : methodIndex.ToString()) +
                "Test";
        }

        private static string GetFullNamespaceName(SyntaxNode node)
        {
            StringBuilder builder = new();
            SyntaxNode current = node;
            while (current.Parent is NamespaceDeclarationSyntax || current.Parent is ClassDeclarationSyntax)
            {
                if (current.Parent is NamespaceDeclarationSyntax ns)
                {
                    builder.Insert(0, $"{ns.Name}.");
                }
                current = current.Parent;
            }
            if (builder.Length > 0)
            {
                builder.Remove(builder.Length - 1, 1);
            }
            return builder.ToString();
        }
    }
}
